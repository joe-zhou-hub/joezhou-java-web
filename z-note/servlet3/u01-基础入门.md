# 1. WEB通信模型

**概念：** web通信就是客户端和服务端基于HTTP协议下的请求和响应的过程：
- 协议：web服务器必须遵守 `HTTP` 协议，其底层是 `TCP/IP` 协议：
    - `TCP` 负责将数据完整的送到目的地，尽管路途中可能会将数据拆成若干小块。
    - `IP` 负责把数据准确地送到目的地。
- 客户端 `client`：指人类用户或者浏览器。
- 服务端 `server`：指物理主机硬件或WEB服务器应用软件。

> z-image/WEB通信模型.jpg

## 1.1 GET请求

**概念：**  GET请求无请求体，用于从服务器快速获取资源：
- GET请求模板：`通信协议://服务器IP或名称:服务器端口/资源所在目录/资源?查询串`
    - 所请求的资源，可以是HTML，PDF，Servlet等。
    - 查询串记录着请求携带的数据，长度有限制。
- GET请求理解：
    - 客户端："嘿！服务器，给我拿（get）下某服务器中的某资源，哦对了，这有一些给你的查询串参数，请快点！"
    - 服务端："好的，我会去拿（get）那个资源，也谢谢你提供的查询串参数，不过有一点要说明，咱俩的HTTP协议中，可没有包含 '快一点' 这一项！"
- GET请求观察：
    - 开发首页 `index.html`，布局 `"HelloWorld"` 文字，部署，运行。
    - 打开浏览器开发者模式，切换到 `Network` 选项卡。
    - 发送get请求:`http://localhost:8080/servlet3/index.html`。
    - 点击 `Network` 中出现的本次请求路径，查看请求响应信息。
    - 查看 `Headers` 选项卡中的 `General` 请求常规信息：
        - `RequestURL`：请求的URL，包括查询串。
        - `RequestMethod`：请求的方式。
        - `Status Code`：请求状态码和状态码文字信息。 
    - 查看 `Headers` 选项卡中的 `Response Header` 响应头信息：
        - `Content-Length`：响应数据的字节大小。
        - `Content-Type`：响应的数据MIME类型。
        - `Date`：响应发生的时间。 
    - 查看 `Headers` 选项卡中的 `Request Header` 请求头信息：
        - `Accept`：设定请求可接收的MIME数据类型列表，响应数据类型不匹配会拒绝。
        - `User-Agent`：请求的浏览器信息。
    - 查看 `Headers` 选项卡中的 `Query String Prameters` 查询串信息。
    - 查看 `Response` 选项卡中的响应的数据。

**布局：** /servlet3/index.html

## 2.2 POST请求

**概念：** POST就是使用请求体携带额外数据的GET请求，牺牲了速度，但安全，传输量更大：
- POST请求理解：
    - 客户端："嘿！服务器，请把这个请求提交（post）给某服务器中的某资源，别忘了看我的请求体，那里面有我发送的一些重要的表单数据！"
    - 服务端："好的，我会去寻找那个地址上的资源，等我找到了，我会把你在请求体中发送的数据交给它！"
- POST请求观察：
    - 在 `index.html` 中开发表单，`action="#"，method="post"`，部署运行。
    - 打开浏览器开发者模式，切换到 `Network` 选项卡。
    - 提交表单，点击 `Network` 中出现的本次请求路径，查看请求响应信息。
    - 额外查看 `Headers` 选项卡中的 `Form Data` 请求体表单数据。

**布局：** /servlet3/index.html

## 2.3 其他请求

**概念：** 大部分浏览器仅支持前两种类型的HTTP请求：
- `get`：请求URL上的一个资源。
- `post`：请求URL上的一个资源，且要求服务器接收附加到请求体中的信息。
- `head`：请求URL上的一个资源，但要求只返回响应头信息，不返回响应体。
- `trace`：请求URL上的一个资源，要求回送请求消息，以便客户端测试或者排错。
- `put`：请求URL上的一个资源，且携带额外一些包含的信息。
- `delete`：请求删除URL上的一个资源。

# 2. Servlet入门

**概念：** 
- Web应用现在炙手可热！而原本的静态HTML页面太死板了，你更希望自己做出来的网站是动态的，交互式的，而且应该是能由客户自己定制的，所以你需要Servlet的帮忙。
- Web服务器擅长提供静态页面，静态页面只是原封不动地待在目录中，服务器要做的就是找到静态页面，然后把它扔到一个响应中，加一些响应头配置之后，原样传回给客户，仅此而已，它是不会负责对页面进行任何加工和修改的。
- 不过有时候我们希望得到一个即时页面（just-in-time），就是那种在请求发出去之前还不存在的页面，比如想在返回来的页面上展示当下的系统时间，这种事情web服务器就做不到了，但是服务器上有一个辅助程序可以做到，于是服务器可以将请求交给这个辅助程序（包括请求中可能伴随的数据），然后再取得这个辅助程序的响应，再把它返回给用户。
- Servlet，就可以担任这样一种辅助程序！
    
**原流程：** 没有Servlet辅助的时候，做不到即时页面的效果。
- 浏览器发送请求。
- 服务器找到资源。
- 服务器响应请求：把资源原封不动放入响应体，然后添加基本响应头后，一起返回给浏览器端。
- 浏览器端接收到响应的数据，解析并渲染页面。
    
**新流程：** 有了Servlet辅助的时候，可以做到即时页面的效果。
- 客户点击一个链接，这个URL指向服务器中的辅助程序，如Servlet的访问入口。
- 服务器"看出"这个请求是发给辅助程序的，于是服务器启动并运行这个辅助程序，如果有参数，也会一并交给它。
- 辅助程序构造了一个全新的HTML页面（插入了系统时间）后，返回给服务器，此时对服务器来说，来自辅助程序的HTML，是一个静态页面。
- 辅助程序关闭，服务端将一个插入了当前系统时间的静态页面响应给浏览器，浏览器进行解析并渲染页面。

## 2.1 导入依赖

**概念：** 使用Servlet前，建议手动导入`servlet-api.jar`，jar包可以从tomcat下的lib包中可以获取，Tomcat7版本之后，使用的是servlet3版本。
    
**配置:**
```xml
<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```

## 2.2 手动XML配通

**概念：** 采取继承、重写、配置的纯手动模式来配置一个Servlet。
- **继承：** 我们新建的java类，就是一个普通的类，想让这个类有资格被叫做Servlet，就必须要继承 `HttpServlet`（Jar包中提供的）。
- **重写：** 重写 `doGet()` 和 `doPost()`，Servlet容器会自动调用 `service()` 的方法，`service()` 方法中可以帮我们分析到底是 `get` 请求还是 `post` 请求，调用对应的方法。
- **配置：** 配置Servlet的位置和访问入口。
    
### 2.2.1 继承 
    
**概念：** 
- 除了 `HttpServlet` 还可以选择通过实现 `Servlet` 接口或继承 `GenericServlet` 类来完成servlet的创建，但是这两种方式均已过时。
- `HttpServlet` 是抽象类 `GenericServlet` 的一个子类，主要负责HTTP协议相关的web容器工作，不能排除世界上的某处还有人使用其他协议进行Servlet开发，但目前最常用的，仍是Http协议。
    
**源码：** 新建 `HelloServlet.java`，并继承 `javax.servlet.http.HttpServlet`
```java
package com.joe.servlet;
import javax.servlet.http.HttpServlet;

/**
 * @author JoeZhou
 * @version 1.0
 */
public class HelloServlet extends HttpServlet {

}
```
    
### 2.2.2 重写 
    
**概念：** 
- `doGet()` 和 `doPost()` 方法的参数应该是 `HttpServletRequest` 和 `HttpServletResponse`。
- 还可以只重写 `service()` 方法，原理是，`service()` 方法能够分析出你请求中的请求类型，然后去帮我们调用对应的 `doGet()` 方法和 `doPost()` 方法。

**源码：** 重写 `doGet()` 和 `doPost()` 方法。
```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
    throws ServletException, IOException {
    
    System.out.println("get进来了...");
}

@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) 
    throws ServletException, IOException {
    
    System.out.println("post进来了...");
}
```
    
### 2.2.3 配置 

**概念：** 在 `web.xml` 文件中进行Servlet的配置，为了让项目能够找到我自己写的Servlet。

标签 | 描述
-|-
`<servlet>` | servlet的基本配置信息
`<servlet-name>` | 配对名，这个名字只有自己知道，浏览器端看不到
`<servlet-class>` | 你的servlet类的类全名
`<servlet-mapping>` | Servlet的映射信息
`<url-pattern>` | Servlet的访问入口，必须以 `/` 开头

```xml
<servlet>
    <servlet-name>HelloServlet</servlet-name>
    <servlet-class>com.joe.controller.HelloServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>HelloServlet</servlet-name>
    <url-pattern>/servlet/hello</url-pattern>
</servlet-mapping>
```
> IDEA中可以选中类，右键 `copy reference` 来复制类全名。

### 2.2.4 访问

- 部署，启动，访问：`http://localhost:8080/servlet3/servlet/hello`。

## 2.2 Servlet即时响应改造

**需求：** 利用辅助程序Servlet完成HTML添加当前系统时间的即时效果。

**源码：**
```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
    throws ServletException, IOException {
    
    // 因为请求头中允许接收html类型[Accept:text/html...]
    // 所以我可以放心的设置内容的MIME类型为text/html
    resp.setContentType("text/html;charset=utf-8");
    
    // 利用IO流从服务端向页面端进行传输[响应]
    PrintWriter writer = resp.getWriter();
    writer.println("<!DOCTYPE html>");
    writer.println("<html>");
    writer.println("<head>");
    writer.println("<meta charset=\"UTF-8\">");
    writer.println("<title>Hello</title>");
    writer.println("</head>");
    writer.println("<body>");
    writer.println("系统时间:" + new Date());
    writer.println("</body>");
    writer.println("</html>");
}

@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) 
    throws ServletException, IOException {
    
    this.doGet(req, resp);
}
```

> 也可以使用字节流进行响应：`ServletOutputStream out = response.getOutputStream();`，但要注意字节流调用的是 `write()` 方法。

## 2.3 手动注解配通

**概念：** 
- 如果你使用的是Servlet3.0以上版本的jar包，则可以使用 `@WebServlet` 注解来配置Servlet，此时将省略 `web.xml` 文件的配置。
- 注解全名为：`javax.servlet.annotation.WebServlet`。
- 如果只设置一个访问入口：
    - `@WebServlet("/servlet/hello")`
    - `@WebServlet(value = "/servlet/hello")`
    - `@WebServlet(urlPatterns = "/servlet/hello")`
- 如果只设置多个访问入口：
    - `@WebServlet(value = {"/servlet/hello", "/servlet/hello1"})`
    - `@WebServlet(urlPatterns = {"/servlet/hello", "/servlet/hello1"})`
    - 
**源码：**
```java
@WebServlet("/servlet/hello")
public class HelloServlet extends HttpServlet {

}
```

## 2.4 Servlet初始化参数

**概念：** 
- 如果想让Servlet在初始化的时候能够设置一些参数
    - 注解配置方案：在 `@WebServlet` 注解中，使用 `initParams` 属性设置。
    - xml配置方案：可以在 `<servlet>` 中配置 `<init-param>`。
- 初始化参数的值，只能是String类型，这里设置的参数只属于它所在的Servlet，其他Servlet看不见。

**注解配置方案源码：**
```java
@WebServlet(urlPatterns = "/servlet/hello", initParams = {
    @WebInitParam(name = "tel1", value = "18210210122"),
    @WebInitParam(name = "tel2", value = "13946002655")
})
```

**xml配置方案配置：**
```xml
<servlet>
    <servlet-name>...</servlet-name>
    <servlet-class>...</servlet-class>
    <init-param>
        <param-name>tel</param-name>
        <param-value>18210210122</param-value>
    </init-param>
</servlet>
```

**取出初始化参数源码：** 在Servlet中获取初始化参数。
```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {
    
    // 从ServletConfig中获取当前这个Servlet的独享的tel信息
    String tel1 = this.getServletConfig().getInitParameter("tel1");
    String tel2 = this.getServletConfig().getInitParameter("tel2");
    System.out.println(tel1);
    System.out.println(tel2);
}
```

> 没有 `setInitParameter()` 方法。

## 2.5 Servlet全局参数

**概念：** 
- 如果想让所有Servlet都共享一些全局参数，那么我门可以在 `web.xml` 中配置 `<context-param>` ，注意不要写在某个 `<servlet>` 中。
- 初始化参数的值，只能是String类型。

**配置：**
```xml
<!--上下文初始化参数，可以写多对儿-->
<context-param>
    <param-name>email</param-name>
    <param-value>yy06200210@163.com</param-value>
</context-param>
```

**取出全局参数源码：** 在Servlet中获取全局参数。
```java
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {
    
    // 从ServletContext中获取所有Servlet共享的email信息
    String email = this.getServletContext().getInitParameter("email");
    System.out.println(email);
}
```

> 没有 `setInitParameter()` 方法。