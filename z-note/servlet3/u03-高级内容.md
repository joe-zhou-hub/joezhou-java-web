# 1. 过滤器

**概念：** servlet过滤器作用于 `service()` 前后，与服务器同生共死：
- 开发过滤器类并实现 `javax.servlet.Filter` 接口。
- 重写过滤器类的 `init()/destroy()/doFilter()`：初始化/销毁/过滤器任务方法：
    - `doFilter()` 中获取 `HttpServletRequest` 和 `HttpServletResponse` 对象。
    - `doFilter()` 中为请求和响应对象统一转码。
    - `doFilter()` 中使用 `chain.doFilter()` 以放行请求到 `service()` 中。
- 注解方式配置：为过滤器类添加 `@WebFilter` 并使用 `value` 属性指定过滤规则。
- XML方式配置：`web.xml` 中：
    - 使用 `<filter>/<filter-name>/<filter-class>` 配置过滤器类。
    - 使用 `<filter-mapping>/<filter-name>/<url-pattern>` 配置过滤规则。
- 开发 `FilterTestServlet` 类：接收中文参数，并写回客户端。

> 过滤规则中不支持前模糊如 `/*/api` 或 `/*User`，但支持后模糊如 `/user*` 或 `/api/*`。

**源码：** /servlet3/
- res: `web.xml`
- src: `c.j.filter.EncodingAnnotationFilter`
- src: `c.j.filter.EncodingXmlFilter`
- src: `c.j.filter.EncodingServlet`
- psm: `{{tomcat}}/servlet3/api/encoding?name=赵四`

## 1.1 非法请求案例

**需求：** 
- 已登录状态下，所有 `/api/*` 路径，都属于正常请求。
- 未登录状态下，除了 `/api/login` 路径之外的所有 `/api/*` 路径，都属于非法请求。

**源码：** /servlet3/
- src: `c.j.filter.IllegalRequestFilter`
- src: `c.j.filter.IllegalRequestServlet`
- psm: `{{tomcat}}/servlet3/api/encoding?name=赵四`，非法请求。
- psm: `{{tomcat}}/servlet3/api/login?name=admin`，登陆成功。
- psm: `{{tomcat}}/servlet3/api/encoding?name=赵四`，允许访问。

# 2. 监听器

**概念：** servlet监听器与服务器同生共死，每种监听器都有不同的使命：
- 开发监听器类并实现 `javax.servlet.ServletContextListener` 接口，监视服务器的生死。
- 重写监听器类的监听方法：
    - `contextInitialized()`：服务器启动时触发。
    - `contextDestroyed()`：服务器关闭时触发。
- 注解方式配置：为监听器类添加 `@WebListener`。
- XML方式配置：`web.xml` 中使用 `<listener>/<listener-class>` 配置监听器类。

**源码：** /servlet3/
- res: `web.xml`
- src: `c.j.listener.XmlListener`
- src: `c.j.listener.AnnotationListener`

## 2.1 访客计数案例

**需求：** 某客户端登录成功时，回写："当前第x个人登录了您的网站！"

**源码：** /servlet3/
- src: `c.j.listener.VisitorCountListener`
- src: `c.j.listener.VisitorCountServlet`
- psm: `{{tomcat}}/servlet3/api/visitor-count?meta=login`

## 2.2 重复登录案例

**需求：** 某客户端重复登陆同一账号时，回写："不允许重复登陆！"

**源码：** /servlet3/
- src: `c.j.listener.RepeatLoginListener`
- src: `c.j.listener.RepeatLoginFilter`
- src: `c.j.listener.RepeatLoginServlet`
- src: `c.j.listener.ExitLoginServlet`
- psm: `{{tomcat}}/servlet3/api/repeat-login?meta=login`
- psm: `{{tomcat}}/servlet3/api/exit-login?meta=login`

## 2.3 其他监听器

**概念：** servlet中除了 `ServletContextListener` 外，还提供了7种类型的监听：
- `ServletRequestListener`：监听请求对象的生死。
- `ServletRequestAttributeListener`：监听请求域中属性添加，修改和移除。
- `HttpSessionListener`：监听会话对象的生死。
- `HttpSessionAttributeListener`：监听会话域中属性添加，修改和移除。
- `HttpSessionBindingListener`：监听其实现类绑定/解绑会话。
- `HttpSessionActivationListener`：监听会话的迁移（vm-a钝化，vm-b激活）。
- `ServletContextAttributeListener`：监听应用域中属性添加，修改和移除。

**源码：** /servlet3/
- src: `c.j.listener.MyRequestListener/MyRequestServlet`
- src: `c.j.listener.MyRequestAttributeListener/MyRequestAttributeServlet`
- src: `c.j.listener.MySessionListener/MySessionServlet`
- src: `c.j.listener.MySessionAttributeListener/MySessionAttributeServlet`
- src: `c.j.listener.User/MyUserBindingServlet`
- src: `c.j.listener.MyApplicationAttributeListener/MyApplicationAttributeServlet`
- psm: `{{tomcat}}/servlet3/api/my-request`
- psm: `{{tomcat}}/servlet3/api/my-request-attribute`
    - `?meta=add/replace/remove`
- psm: `{{tomcat}}/servlet3/api/my-session`
    - `?meta=create/destroy`
- psm: `{{tomcat}}/servlet3/api/my-session-attribute`
    - `?meta=add/replace/remove`
- psm: `{{tomcat}}/servlet3/api/my-user-binding`
    - `?meta=bound/unbound`
- psm: `{{tomcat}}/servlet3/api/my-application-attribute`
    - `?meta=add/replace/remove`

# 3. 报表打印

**概念：** 我们可以利用 `Servlet` 来将数据对应打印在一个Excel表格文件中。

**流程：** 
1. **引入依赖：** 因为我们要使用是一个转换器，这个转换器是第三方jar包中的 `XLSTransformer` 类。
2. **准备模板：** 准备一个Excel模板，Excel模板中使用EL表达式和  `<jx>` 标签来取值。
3. **准备数据：** 数据的类型是Map类型，Map里面我们存放数据和标题，或者其他内容。
4. **创建Servlet：** 创建 `ExcelServlet.java`。
5. 使用`transformer.transformXLS()`，进行Map数据和Excel文件的一个转换。
    - p1：文件的模板，得告诉转换器按照怎样的一个格式来转换
    - p2：数据，得告诉转换器，你要转什么内容
    - p3：输出路径，得告诉转换器将文件转换成功后放在哪里（必须带文件名）
（可选）如果想下载下来，可以直接重定向这个文件的位置。

**链接：** [studentTemplate.xls](http://note.youdao.com/noteshare?id=06b2ef6b6653389185faee47c2107f03&sub=03DDCE1673464C849E6EA6729C089D3D)

## 2. 引入依赖

**配置：** pom.xml
```xml 
<dependency>
    <groupId>net.sf.jxls</groupId>
    <artifactId>jxls-core</artifactId>
    <version>1.0-RC-2</version>
</dependency>
```

## 3. 准备Excel模版

**概念：** 在 `/view/template` 下新建一个template.xls模板

![](https://user-gold-cdn.xitu.io/2020/4/28/171bfbbf67f7eb18?w=910&h=320&f=png&s=12474)

## 4. 准备数据

**概念：** 准备一套 `List<Map>` 结构的数据，当然，也可以使用 `List<Pojo>` 结构的数据，但无论准备的是什么格式的数据，最终都要放到一个 `Map` 中。

**源码：**
```java
/**
 * @author JoeZhou
 */
public class ExcelDataTool {

    public static Map<String, Object> getStudents() {
        // 标题
        String title = "学生成绩单";

        // 报表内容
        List<Map<String, Object>> students = new ArrayList<>();

        // 结果数据：最终返回的数据
        Map<String, Object> resultData = new HashMap<>(10);


        // 学生数量
        int studentsLength = 100;

        // 循环注入100个学生
        for (int i = 1; i <= studentsLength; i++) {
            Map<String, Object> map = new HashMap<>(3);
            map.put("id", "00" + i);
            map.put("name", "赵四" + i);
            map.put("score", i + 1);
            students.add(map);
        }

        // 将内容和标题都放到结果数据中
        resultData.put("title", title);
        resultData.put("students", students);

        return resultData;
    }
}
```

## 5. 准备Servlet

**概念：** 文件输出位置文件夹也可以手动在 `tomcat/webapps/` 项目的发布路径下创建。

**源码：** ExcelServlet.java
```java
/**
 * @author JoeZhou
 */
@WebServlet("/servlet/excel")
public class ExcelServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {

        // excel模版路径：告诉我你的excel模板在哪里
        String path = "/view/template/studentTemplate.xls";
        String templatePath = req.getServletContext().getRealPath(path);

        // excel文件输出位置文件夹：告诉我你生成的excel文件放到哪里
        String excelDirPath = req.getServletContext().getRealPath("/excel");

        File file = new File(excelDirPath);

        // 如果excel文件夹不存在，则创建一个。
        if (!file.exists()) {
            boolean mkdirs = file.mkdirs();
            System.out.println(mkdirs);
        }

        // 创建一个xls转换器，用于将数据转换成xls语言
        XLSTransformer transformer = new XLSTransformer();

        // 将数据转换成excel格式，需要抛异常
        // 参数1：模版文件路径
        // 参数2：待转换数据
        // 参数3：转换后文件路径：需要自己设置文件名，后缀必须是xls，可以使用中文。
        // 理解：将[参数2]按照[参数1]的格式转成[参数3]
        try {
            transformer.transformXLS(templatePath, ExcelDataTool.getDataMap(), excelDirPath + "/students.xls");
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 直接重定向访问要打印的文件可以下载文件，但这种方式无法识别中文，如果是中文，使用IO流下载
        resp.sendRedirect(req.getContextPath() + "/excel/students.xls");
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
        this.doGet(request, response);
    }
}
```

