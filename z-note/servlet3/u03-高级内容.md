# 1. 过滤器

**概念：** servlet过滤器作用于 `service()` 前后，与服务器同生共死：
- 开发 `EncodingFilter` 过滤器类并实现 `javax.servlet.Filter` 接口。
- 重写 `init()/destroy()` 生命周期方法和 `doFilter()` 过滤器任务方法：
    - `doFilter()` 中获取 `HttpServletRequest` 和 `HttpServletResponse` 对象。
    - `doFilter()` 中为请求和响应对象统一转码。
    - `doFilter()` 中使用 `chain.doFilter()` 以放行请求到 `service()` 中。
- 注解方式配置：为 `EncodingFilter` 类添加 `@WebFilter` 并指定过滤规则：
- XML方式配置：`web.xml` 中用 `<filter>` 和 `<filter-mapping>` 组合配置：
    - 子标签 `<filter-name>`：配置过滤器配对名。
    - 子标签 `<filter-class>`：配置过滤器类全名。
    - 子标签 `<url-pattern>`：配置过滤规则。
- 开发 `FilterTestServlet` 类：接收中文参数，并写回客户端。

> 过滤规则中支持使用 `*`，但不支持前模糊如 `/*Servlet` 的写法，只能后模糊如 `/servlet*` 的写法。

**源码：** /servlet3/
- res: `web.xml`
- src: `c.j.filter.EncodingAnnotationFilter`
- src: `c.j.filter.EncodingXmlFilter`
- src: `c.j.filter.FilterTestServlet`
- psm: `{{tomcat}}/servlet3/api/filter-test?name=赵四`

## 1.1 过滤非法登录案例

**需求：** 
- 登录状态下，所有 `/servlet/*` 路径，都属于正常请求。
- 未登录状态下，除了 `/servlet/login` 路径之外的所有 `/servlet/*` 路径，都属于非法入侵。

**布局：** error.html，非法登录失败页面
```html
<section>非法登录</section>
```

**源码：** LoginServlet.java
```java
if (result) {

    // 登录成功后将账号存入session
    HttpSession session = req.getSession();
    synchronized (session) {
        session.setAttribute("username", username);
    }

    req.getRequestDispatcher("/view/html/student.html").forward(req, resp);
}
```

**源码：** MyIllegalLoginFilter.java
```java
/**
 * @author JoeZhou
 */
@WebFilter("/servlet/*")
public class MyIllegalLoginFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) {
        System.out.println("MyIllegalLoginFilter被创建了...");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;

        String uri = req.getRequestURI();
        String effectivePath = "/servlet/login";
        if (uri.contains(effectivePath) || isLoggedIn(req, resp)) {
            chain.doFilter(req, resp);
        } else {
            String xRequestedWith = req.getHeader("x-requested-with");
            String xRequestedWithValue = "XMLHttpRequest";
            if(xRequestedWithValue.equals(xRequestedWith)){
                // 是AJAX请求
                resp.getWriter().println(JsonTool.build(500, "非法登录", null));
            }else{
                // 不是AJAX请求
                req.getRequestDispatcher("/view/html/err.html").forward(req, resp);
            }
        }
    }

    private boolean isLoggedIn(HttpServletRequest req, HttpServletResponse resp) {
        boolean result = false;
        HttpSession session = req.getSession();
        synchronized (session) {
            String username = (String) session.getAttribute("username");
            result = (username != null);
        }
        return result;
    }

    @Override
    public void destroy() {
        System.out.println("MyIllegalLoginFilter被销毁了...");
    }
}
```