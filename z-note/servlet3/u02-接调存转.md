# 1. servlet接值

**概念：** servlet使用 `request` 对象来接收请求路径和请求头中的数据：
- `void setCharacterEncoding("UTF-8")`：设置请求编码。
- `String getParameter(String name)`：通过name值接收单个请求参数。
- `String[] getParameterValues(String name)`：通过name值接收多个请求参数。
- `String getRequestURI()`：获取请求路径，不包括协议，IP和端口。
- `StringBuffer getRequestURL`：获取请求全路径，包括协议，IP和端口。
- `String getServerName()`：获取服务器IP地址，如 `localhost`。
- `String getServerPort()`：获取端口号，如 `8080`。
- `String getContextPath()`：获取项目名称，如 `/servlet3`。
- `String getServletPath()`：获取servlet路由，如 `/api/servlet/request`。
- `String getQueryString()`：获取查询串，如 `a=1&b=2`。
- `String getHeader(String name)`：通过name值获取指定的请求头信息。
- `Cookie[] getCookies()`：获取请求头中的所有Cookie信息。

**源码：** /servlet3/
- src: `c.j.work.servlet.RequestServlet`
- psm: `{{tomcat}}/servlet3/api/request?username=赵四&id=1&id=2`

# 2. servlet调用

**概念：** MVC架构就是对软件进行分层以达到解耦的目的：
- 视图层 `view`：只负责搭建前端页面：
    - 通过表单，超链接，AJAX等方式向控制层传递数据。
- 控制层 `controller`：只负责与视图层交互数据：
    - 接：接收视图层的请求相关数据。
    - 调：调用业务层方法。
    - 存：存储相关数据。
    - 转：对视图层的请求做出响应。
- 模型层 `model`：从控制层分离出来的java类：
    - 实体类 `pojo`：用于映射数据库对象，存储和传输数据。
    - 业务类 `service`：只负责对数据进行业务逻辑处理，面向接口开发。
    - 数据类 `dao`：利用JDBC与数据库交互数据，面向接口开发。
- MVC架构案例-登陆：
    - 数据库开发：数据库，账户，表，测试数据...
    - JDBC开发：创建maven项目 `pro-jdbc`，install本地仓库。
    - servlet3项目依赖：引入servlet，lombok和jdbc依赖。
    - pojo开发：对应数据表的实体类。
    - dao开发：开发登陆方法，测试。
    - service开发：开发登陆业务方法，测试。
    - controller开发：开发登陆接口方法。
    - view开发：编写视图层界面。

**源码：** /servlet3/
- res: `pom.xml`
- res: `resources/db.properties`
- src: `c.j.work.pojo.Account`
- src: `c.j.work.dao.AccountDao`
- src: `c.j.work.dao.impl.AccountDaoImpl`
- src: `c.j.work.service.AccountService`
- src: `c.j.work.service.impl.AccountServiceImpl`
- src: `c.j.work.servlet.AccountServlet`
- web: `html/login.html`
- tst: `c.j.dao.AccountDaoTest`
- tst: `c.j.service.AccountServiceTest`
- psm: `{{tomcat}}/servlet3/api/account?meta=login&username=admin`

# 3. servlet存值

**概念：** servlet中使用 `request`，`session` 和 `application` 可以进行存取值操作，三者API方法一致，生命周期不同：
- 通用API方法：
    - `setAttribute(K, V)`：以键值对的方式存值，同名覆盖。
    - `getAttribute(K)`：通过K取出对应的V，不存在返回null。
- request域：时效为一次请求，请求得到响应后，立即死亡。
- session域：时效为一次会话，浏览器关闭且在失效时间内无任何请求访问它时死亡：
    - `req.getSession()`：通过请求获取HttpSession对象，若不存在则创建一个新的并返回。
    - `req.getSession(true)`：等效于 `getSession()`。
    - `req.getSession(false)`：通过请求获取session，若不存在返回null。
    - `session.isNew()`：返回session是否是最新创建的。
    - `session.getId()`：返回 `sessionId`。
    - `session.setMaxInactiveInterval()`：设置失效时间间隔-秒，-1表示session永生。
    - `session.getMaxInactiveInterval()`：查看失效时间间隔-秒，默认1800秒。
    - `session.invalidate()`：session立刻失效，等效于 `setMaxInactiveInterval(0)`。
- application域：时效为一次应用，服务器重启，崩溃，关闭时死亡：
    - `req.getServletContext()`：通过请求获取ServletContext对象。

> 也可以在 `web.xml` 中指定 `<session-config>` 和 `<session-timeout>` 来设置session失效时间间隔-秒。

**源码：** /servlet3/
- res: `web.xml`
- src: `c.j.work.servlet.StoreServlet`
- psm: `{{local}}/servlet3/api/store?meta=request`
- psm: `{{local}}/servlet3/api/store?meta=session`
- psm: `{{local}}/servlet3/api/store?meta=application`

## 3.1 session长连接原理

**概念：** HTTP协议是无状态的，每个请求对它来说都是新的，若需要长久保存数据，建议使用session域：
- 当session被创建时，会生成一个 `sessionID`，并响应到浏览器的cookie中存储起来。
- 当前浏览器以后的每一个请求都会携带这个 `sessionID` 信息。
- 当web容器看到 `sessionID` 后，会去寻找对应的session，并将其和本次请求关联起来。
- 所以不同的电脑，或者同一台电脑中的不同的浏览器都是不能共享session的。

## 3.2 存值域线程安全问题

**概念：** web容器为每个请求分配一个线程，这些线程是并发执行的，会产生线程安全问题：
- 线程安全问题：
    - A线程进来 `session.setAttribute("money", 100)`
    - A线程挂起...
    - B线程进来 `session.setAttribute("money", 200)`
    - B线程挂起...
    - A线程苏醒，调用 `session.getAttribute("money")`，得到的居然是200
- session域和application域中存储的资源都是线程不安全的，建议同步加锁，以效率换取安全：
    - 不能使用this锁，因为它只能阻止同一个servlet中的不同线程，但不能阻止不同的servlet的线程。
    - 不能在 `doGet()` 或 `doPost()` 上加锁，因为非静态方法的锁也是this锁。
    - 建议使用锁类型为session或application对象本身。
- request域是线程安全的，request中存储的资源在请求时就被销毁了：
    - 请求属性和方法局部变量是servlet中线程最安全的位置。
- STM设计模式：该设计模式保证一个servlet一次只处理一个请求，效果和同步 `doGet()/doPost()` 一样，使用方法很简单，只要让servlet实现 `SingleThreadModel` 接口即可，它有两种策略，一种是让请求排队，一种是维护servlet实例池，并发处理请求，具体使用哪种策略取决于容器开发商，但这两种策略，前者牺牲太多效率，后者违反了servlet的单例规范，所以目前STM已经被ServletAPI废弃掉了，对于STM，它早已退出江湖，而你只需要知道，这名战士，它曾经试图保护过servlet属性的线程安全，就足够了。

**源码：** /servlet3/
- src: `c.j.work.servlet.SyncServlet`

# 4. servlet转页

**概念：** 转页方式指的就是响应方式，比如请求转发，重定向，响应cookie数据，响应数据等：
- response对象常用API方法：
    - `addCookie()`：添加一个cookie，web容器会自动的将其回写到客户端。
    - `addHeader()`：添加一个字符串类型的响应头信息，如重定向的 `location`。
    - `setHeader()`：修改一个字符串类型的响应头信息，如重定向的 `location`。
    - `addIntHeader()`：添加一个数字类型的响应头信息。
    - `setIntHeader()`：修改一个数字类型的响应头信息。
    - `addDateHeader()`：添加一个日期类型的响应头信息，如cookie的 `expires`。
    - `setDateHeader()`：修改一个日期类型的响应头信息，如cookie的 `expires`。
    - `setContentLength()`：设置响应数据的长度。
    - `setContentType()`：设置响应头中 `content-type` 的内容。
    - `setStatus()`：设置响应码，如200、404等。
    - `getOutputStream()`：获取一个响应字节流 `ServletOutputStream` 实例。
    - `getWriter()`：获取一个响应字节流 `PrintWriter` 实例。
    - `sendRedirect()`：用于请求重定向，等效于响应头中的 `location`。
    - `containsHeader()`：判断是否含有指定的响应头信息字段。
    - `encodeURL()`：用于url改写的功能，和session有关。

**源码：** /servlet3/
- src: `c.j.work.servlet.ResponseServlet`
- psm: `{{local}}/servlet3/api/response`

## 1. 请求转发

**概念：** 
- 之前我们接触过利用 `PrintWriter` 的方式来返回一个动态HTML，但是未免太过麻烦，而且将HTML代码写在Servlet中也不是一件很舒服的事情，所以我们需要Servlet能够使用几行代码，来展示一个真正的HTML文件作为一次响应，换句话说，Servlet可以将这部分工作转发给别人（当然，请求和响应的参数也得同时交出去，因为此后自己将不再干任何有关请求和响应的事情），比如转发给另一个Servlet、一个jsp文件、一个HTML文件等，它们接到这个任务之后，开始干活（解析成HTML文件），然后将HTML展示在浏览器上，如果是某个HTML接到了这个任务，就更简单了，直接将自己展示在浏览器上就OK了。
- 请求转发或者重定向之后，再写任何代码，都是死代码，会抛出`IllegalStateException`异常。

**流程：**
- 获取转发器同时绑定转发对象：`RequestDispatcher dispatcher = req.getRequestDispatcher("/view/main.html");`
- 转发器开始转发
    - `forward()`：这个任务给你了，我不会再做处理这个请求和响应的任何事情。
    - `include()`：我想让别人帮忙处理这个请求或者响应，但是它们一旦工作结束，我会再接管回来，自己完成请求和响应的最后处理，而且在此之后，我可能会决定再使用另一个 `include()` 或 `forward()`，实际中一般不会用到这个方法。

**布局：** 在 `webapp` 文件夹下建立一个 `view` 文件夹，在其中新建一个 `main.html` 当做登录成功之后展示的页面。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    登录成功!
</body>
</html>
```

**源码：** 在LoginServlet最后响应的位置使用请求转发
```java
/**
 * @author JoeZhou
 * @version 1.0
 */
@WebServlet("/servlet/login")
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        
        req.setCharacterEncoding("utf-8");
        resp.setContentType("text/html;charset=utf-8");

        String username = req.getParameter("username");
        String password = req.getParameter("password");

        LoginService loginService = new LoginServiceImpl();
        boolean result = loginService.login(username, password);

        if (result) {
            // 从请求中得到一个[转发器]，并指定资源路径，资源路径之前建议填写"/"，代表从工程的根出发寻找
            RequestDispatcher dispatcher = req.getRequestDispatcher("/view/main.html");

            // 调用forward方法，告诉[转发器]，让它将请求转发给main.html，并将请求和响应对象交给它
            dispatcher.forward(req, resp);
        } else {
            req.getRequestDispatcher("/index.html").forward(req, resp);
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) 
        throws ServletException, IOException {
        
        this.doGet(req, resp);
    }
}
```

> `RequestDispatcher` 实例也可以通过 `ServletContext` 获取，效果一样，但它约定路径前必须有"/"。

## 2. 重定向

**概念：** 重定向和请求转发是有区别的
- **请求转发：** 一个请求发给服务器，web容器帮我们执行任务，这就是请求转发的工作模式，请求转发的路径直接从 `webapp` 文件夹下下粘贴路径，页面转发时地址栏不会发生变化。
- **重定向：** 一个请求发给服务器，web容器不帮我们执行，而是返回一个目标地址，我们自己按照目标地址去执行任务，这就是重定向的工作模式，重定向的路径前需要补充项目发布名，页面转发时地址栏会发生改变。
- 重定向是两次请求，而请求转发是一次请求，所以原则上，能使用请求转发就不要使用重定向。

**源码：** 在LoginServlet最后响应的位置使用请求转发
```java
/**
 * @author JoeZhou
 * @version 1.0
 */
@WebServlet("/servlet/login")
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        
        req.setCharacterEncoding("utf-8");
        resp.setContentType("text/html;charset=utf-8");

        String username = req.getParameter("username");
        String password = req.getParameter("password");

        LoginService loginService = new LoginServiceImpl();
        boolean result = loginService.login(username, password);

        if (result) {
            // 重定向跳到主页面
            resp.sendRedirect(req.getContextPath() + "/view/main.html");
        } else {
            // 重定向跳回登录页面
            resp.sendRedirect(req.getContextPath() + "/index.html");
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) 
        throws ServletException, IOException {
        
        this.doGet(req, resp);
    }
}
```

## 2.1 重定向防刷新

**概念：** 
- 我有一个需求，就是我想吃一个面包，这个需求发送给了班长，班长去帮我买了一个面包，这就是请求转发的工作模式。
- 如果我是结巴，说了两遍我想吃一个面包，那么班长就会给我买两个面包，这个结果很明显不是我想要的，这个时候就需要使用重定向，因为重定向的原理是，当这个需求发送给了班长，班长不会帮我去买，而是告诉我哪里有卖，然后我自己重新定义方向，自己去买，这样即使我是结巴，只要不是傻子，就不会买两个面包给自己。
- 客户永远是伟大的，你永远防止不了客户的刷新欲望，刷新就相当于在重走地址栏，如果在添加新员工的业务中，用户无限地去刷新，而刚好你用的又是请求转发的方式，那么恭喜你，每次刷新，你都将会获得一个新的员工。
- 所以在添加业务中，为了防止刷新带来的错误结果，请不要使用请求转发进行转页。

## 2.2 WEB-INF下的重定向

**概念：** 当我们想要跳转的JSP文件在 `WEB-INF` 下，请求转发并无影响，但重定向会失败，这时我们可以通过更改 `web.xml` 进行映射。

**配置：** 例如有个 `/WEB-INF/jsp/jsp.html`
```xml
<servlet>
    <servlet-name>my</servlet-name>
    <jsp-file>/WEB-INF/jsp/my.jsp</jsp-file>
</servlet>
<servlet-mapping>
    <servlet-name>my</servlet-name>
    <url-pattern>/myfile</url-pattern>
</servlet-mapping>
```

**源码：**
```java
// 通过重定向来达到访问 /WEB-INF/jsp/my.jsp 的目的
response.sendRedirect(request.getContextPath()+"/myfile");
```


## 3. 识别AJAX请求

**概念：** 
- 有时我们需要先判断请求是否是AJAX请求，因为对于AJAX请求来说，请求转发和重定向这两种方式都是失效的，只能使用IO流回写数据。
- AJAX请求的请求头会多出一个请求头 `x-requested-with = "XMLHttpRequest"`，可以通过debug查看到。

![](https://user-gold-cdn.xitu.io/2020/4/29/171c416fc23188b6?w=1293&h=661&f=png&s=76110 "coyoteRequest -> headers -> headers -> 5")

**源码：** 判断请求是否是AJAX请求
```java
String requestedWith = req.getHeader("x-requested-with");
if (requestedWith != null  &&  requestedWith.equals("XMLHttpRequest")) {
    System.out.println("本次请求是AJAX请求，使用IO回写");
    resp.setContentType("application/json;charset=utf-8");
    resp.getWriter().print("{a:1}");
}else {
    System.out.println("本次请求不是AJAX请求，使用重定向");
    resp.sendRedirect(req.getContextPath() + "/index.html");
}
```

## 1. JSON支持

**概念：** 
- 如果做前后端分离，JSON无疑是最佳的数据传输对象，JSON有很多封装的工具，比如谷歌的GSON，原生的JsonArray等，这里我们使用Jackson。
- JSON数据需要配合页面端的AJAX技术进行调用。
- 如果要返回JSON数据，建议修改响应内容：
    - `resp.setContentType("application/json;charset=utf-8");`

## 2. Jackson

## 2.1 引入Jackson依赖包

**配置：** pom.xml
```xml
<!-- jackson-core -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId><artifactId>jackson-core</artifactId>
    <version>2.9.7</version>
</dependency>

<!-- jackson-annotations -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId><artifactId>jackson-annotations</artifactId>
    <version>2.9.7</version>
</dependency>

<!-- jackson-databind -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId><artifactId>jackson-databind</artifactId>
    <version>2.9.7</version>
</dependency>
```

## 2.2 Jackson转换JSON串

**概念：** 利用 `writeValueAsString(accounts)` 将数据 `accounts` 转为一个JSON字符串。
- p1：待转数据，支持 `List`、`Set`、`Map` 等数据结构。
- 返回值：返回一个JSON字符串。

**源码：** 
```java
resp.setContentType("application/json;charset=utf-8");
ObjectMapper objectMapper = new ObjectMapper();
// 只有不为null的属性才被序列化
objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
// 禁止使用时间戳
objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
// 自定义日期的格式
objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
String jsonStr = objectMapper.writeValueAsString(accounts);
resp.getWriter().write(jsonStr);
```

## 2.3 Jackson其他API

**概念：** Jackson还可以利用 `writeValue(resp.getWriter(), accounts)` 方法转换为JSON数据并直接回写。
- p1：回写数据的方式
    - 如果是一个 `File` 对象，表示将数据转换为JSON字符串，并保存到指定的文件中。
    - 如果是一个 `PrintWriter` 对象，表示将数据转换为JSON字符串，并将其回写到字符输出流中。
    - 如果是一个 `ServletOutputStream` 对象，表示将数据转换为JSON字符串，并将其回写到字节输出流中。
- p2：待转数据，支持 `List`、`Set`、`Map` 等数据结构。
- 返回值：`void`。

**源码：**
```java
resp.setContentType("application/json;charset=utf-8");
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.writeValue(resp.getWriter(), accounts);
```

## 3. Gson

**链接：** [gson-1.4.jar](http://note.youdao.com/noteshare?id=28e98cded8a92f80095b2efc4126799e&sub=35D20219F402466A8C59721293EE6FEF)

## 3.1 引入Gson依赖包

**配置：** pom.xml
```xml
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.5</version>
</dependency>
```

## 3.2 Gson转换JSON串

**概念：** 
- 利用 `toJson(accounts)` 将数据 `accounts` 转为一个JSON字符串。
    - p1：待转数据，支持 `List`、`Set`、`Map` 等数据结构。
    - 返回值：返回一个JSON字符串。
- 如果数据库的值为1或者0，则Gson会将其默认转成true或则false类型。

**源码：**
```java
resp.setContentType("application/json;charset=utf-8");
Gson gson = new Gson();
String jsonStr = gson.toJson(accounts);
resp.getWriter().print(jsonStr);
```

## 3.3 Gson转换中处理null值

**概念：** Gson默认会将所有null值字段删除，如果想保留数据中的所有null值，则需要更改Gson对象的创建方式。

**源码：** 
```java
resp.setContentType("application/json;charset=utf-8");
Gson gson = new GsonBuilder().serializeNulls().create();
String jsonStr = gson.toJson(accounts);
resp.getWriter().print(jsonStr);
```

## 3.4 Gson转换中处理日期格式

**概念：** Gson支持在转换过程中，自定义日期格式数据的格式。

**源码：** 
```java
resp.setContentType("application/json;charset=utf-8");
Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create();
String jsonStr = gson.toJson(accounts);
resp.getWriter().print(jsonStr);
```

## 4. JsonArray

**链接：** [jsonarrayjars.zip](http://note.youdao.com/noteshare?id=3b5aa0d8e2354e08e682b43f2b380d3e&sub=BC1A80E8B6D54DB8B651CE8950A2AF1E)

## 4.1 引入JsonArray依赖包

**配置：** pom.xml
```xml
<dependency><groupId>commons-beanutils</groupId><artifactId>commons-beanutils</artifactId><version>1.9.3</version></dependency>

<dependency><groupId>commons-collections</groupId><artifactId>commons-collections</artifactId><version>3.2.1</version></dependency>
        
<dependency><groupId>commons-lang</groupId><artifactId>commons-lang</artifactId><version>2.6</version></dependency>
        
<dependency><groupId>commons-logging</groupId><artifactId>commons-logging</artifactId><version>1.1.1</version></dependency>

<dependency><groupId>net.sf.ezmorph</groupId><artifactId>ezmorph</artifactId><version>1.0.6</version></dependency>

<dependency><groupId>net.sf.json-lib</groupId><artifactId>json-lib</artifactId><version>2.2.3</version><classifier>jdk15</classifier></dependency>
```

## 4.2 JsonArray转换JSON串

**概念：** 
- 利用 `fromObject(accounts).toString()` 将数据 `accounts` 转为一个JSON字符串。
    - p1：待转数据，支持 `List`、`Set`、`Map` 等数据结构。
    - 返回值：返回一个JSON字符串。

**源码：**
```java
resp.setContentType("application/json;charset=utf-8");
String jsonStr = JSONArray.fromObject(accounts).toString();
resp.getWriter().print(jsonStr);
```
